\documentclass[11pt]{article}
\usepackage{acl2014}
\usepackage{times}
\usepackage{url}
%\usepackage{geometry}
%\geometry{left=2cm,right=2cm,top=2.5cm,bottom=2.5cm}
\usepackage{latexsym}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{CJKutf8}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{subfigure}

\newtheorem{myTheo}{Theorem}

\newenvironment{proof}{\hspace{0ex}\textsc{Proof}.\hspace{1ex}}{\hfill$\Box$\newline} 

% Use the postscript times font!
\usepackage{times}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning}
\tikzset{
    %Define standard arrow tip
        >=stealth',
        % Define arrow style
            pil/.style={
                ->,
                thick,
                shorten <=2pt,
                shorten >=2pt,}
}

\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\tableref}[1]{Table~\ref{#1}}

\begin{document}

\title{Improving Lexical Embeddings with Semantic Knowledge}

\author{Mo Yu \thanks{This work was done while the author was visiting JHU.} \\
  Machine Translation Lab \\
  Harbin Institute of Technology \\
  Harbin, China  \\
  {\tt gflfof@gmail.com} \\\And
  Mark Dredze \\
  Human Language Technology Center of Excellence \\
  Center for Language and Speech Processing \\
  Johns Hopkins University \\
  Baltimore, MD 21218 \\
  {\tt mdredze@cs.jhu.edu} \\}

\date{}
\maketitle

\begin{abstract}

%Word embeddings have been successfully applied to syntactic analysis and semantic analysis tasks. 
Word embeddings learned on unlabeled data are a popular tool in semantics, but may not 
capture the desired semantics.
We propose a new learning objective that incorporates both a neural language model objective \cite{mikolov2013distributed}
and prior knowledge from semantic resources to learn improved lexical semantic embeddings.
We demonstrate that our embeddings improve over those learned solely on raw text in three settings:
language modeling, measuring semantic similarity, and predicting human judgements.
\end{abstract}

\section{Introduction}
\label{sec:intro}

%I don't have a lot to comment on at the moment, beyond the basic point
%that you should cite more papers such as those below.  While the
%community is all excited about supervised training of embeddings,
%which is indeed a nice thing, they should remember that there was
%prior work in unsupervised, randomized embeddings into {1,0}^d  (bit
%vectors), which were also trained based on n-grams (Deepak, and then
%me 2010) and in PPDB itself, where Juri pulled syntactic counts from
%Annotated Gigaword and similarly embedded them.  In all cases the
%resultant embeddings preserve cosine of the original feature space.
%"Neural embeddings" != "all embeddings".
%
%
%Tsz Ping Chan, Chris Callison-Burch and Benjamin Van Durme. Reranking
%Bilingually Extracted Paraphrases Using Monolingual Distributional
%Similarity. EMNLP Workshop: GEMS. 2011.
%\cite{chan2011reranking}
%and/or:
%
%Benjamin Van Durme and Ashwin Lall. Online Generation of Locality Sensitive Hash Signatures. ACL Short. 2010.
% \cite{van2010online}
%and previous:
%
%Deepak Ravichandran, Patrick Pantel, and Eduard Hovy. 2005. Randomized Algorithms and NLP: Using Locality Sensitive Hash Functions for High Speed Noun Clustering. In Proceedings of ACL.
%\cite{ravichandran2005randomized}

Word embeddings are popular representations for syntax \cite{turian2010word,collobert2008unified,mnih2007three}, semantics
\cite{huang2012improving,socher-EtAl:2013:EMNLP}, morphology \cite{luong2013better} and other areas.
A long line of embeddings work, such as LSA and randomized embeddings \cite{ravichandran2005randomized,van2010online},
has recently turned to neural language models \cite{bengio2006neural,collobert2008unified,turian2010word}.
Unsupervised learning can
take advantage of large corpora, which can produce impressive results.

However, the main drawback of unsupervised learning is that the learned embeddings
may not be suited for the task of interest.
Consider semantic embeddings, which may capture a notion of semantics that 
improves one semantic task but harms another.
Controlling this behavior is challenging with an unsupervised objective.
However, rich prior knowledge exists for many tasks, and there are
numerous such semantic resources.

%current strategies of training embeddings aim to optimize the objectives of language modeling, thus are mismatched to the scenarios to which embeddings are applied. Such disadvantage makes the learned embeddings far from optimal. The situation will become worse for the semantic analysis tasks, where the training objectives are greatly different from those of language models. 

We propose a new training objective for learning word embeddings that incorporates prior knowledge.
Our model builds on word2vec %\cite{mikolov2013distributed,mikolov2013efficient,Mikolov:2013fk},
\cite{mikolov2013distributed},
a neural network based language model that learns word
embeddings by maximizing the probability of raw text.
%By Mo
We extend the objective to include prior knowledge about synonyms from semantic resources;
we consider both the Paraphrase Database \cite{ganitkevitch2013ppdb} and WordNet \cite{fellbaum1999wordnet},
which annotate semantic relatedness between words. 
%By Mo
The latter was also used in \cite{bordes2012joint} for training a network for predicting synset relation.
The combined objective maximizes both the probability of the raw corpus 
and encourages embeddings to capture semantic relations from the resources.
We demonstrate improvements in our embeddings
on three tasks: language modeling, measuring word similarity, and predicting human judgements 
on word pairs.
%Results show that incorporation of these resources yields embeddings more suited to semantic similarity tasks.
%We try to overcome this difficulty by proposing three ways for evaluating the semantic aspects of embeddings. First, based on PPDB and WordNet, we build two tasks for directly evaluating whether a set of embeddings can give similar representations to paraphrases. Second, we evaluate embeddings based on the task of monolingual alignment \cite{yao-EtAl:2013:Short}, in order to investigate the usefulness of embeddings in downstream applications where semantic representations of words are in need.

\vspace{-.1cm}
\section{Learning Embeddings}
\label{sec:train}
\vspace{-.1cm}
We present a general model for learning word embeddings that incorporates prior
knowledge available for a domain. While in this work we consider semantics, our model
could incorporate prior knowledge from many types of resources.
We begin by reviewing the word2vec objective and then present
augmentations of the objective for prior knowledge, including different training strategies.

\subsection{Word2vec}

Word2vec \cite{mikolov2013distributed} is an algorithm for learning embeddings using a neural language model.
Embeddings are represented by a set of latent (hidden) variables, and each word is represented by a specific instantiation of these 
variables. Training learns these representations for each word $w_t$ (the $t$th word in a corpus of size $T$)
so as to maximize the log likelihood of each token given its context: words within a window sized $c$:
\begin{equation}
\max \frac{1}{T} \sum_{t=1}^{T} \log p\left( w_t | w_{t-c}^{t+c} \right),
\label{eq:word2vec}
\end{equation}
where $w_{t-c}^{t+c}$ is the set of words in the window of size $c$ centered at $w_t$ ($w_t$ excluded).

Word2vec offers two choices for modeling of Eq. \eqref{eq:word2vec}: a skip-gram model and
a continuous bag-of-words model (cbow). The latter worked better in our experiments so we focus on it in our presentation.
cbow defines $p(w_t|w_{t-c}^{t+c})$ as:
\vspace{-.1cm}
\begin{equation}
\vspace{-.1cm}
\frac{\exp\left( {e^{'}_{w_t}}^\top \cdot \sum_{-c \le j \le c, j \ne 0}  e_{w_{t+j}} \right)}{\sum_w \exp\left( {e^{'}_{w}}^\top \cdot \sum_{-c \le j \le c, j \ne 0}  e_{w_{t+j}} \right)},
%\vspace{-.1cm} %By Mo
\label{eq:cbow}
\end{equation}
where $e_w$ and $e^{'}_w$ represent the input and output embeddings respectively, i.e., the assignments to the latent variables
for word $w$. While some learn a single representation for each word ($e'_w \triangleq e_w$), our results improved when
we used a separate embedding for input and output in cbow.

%Taking the skip-gram model \cite{mikolov2013distributed} as an example, given a sentence $w_1, w_2, ..., w_T$, the objective of the skip-gram model is



\iffalse
For the skip-gram model, $p(w_t|w_{t-c:t+c})$ is
\begin{equation}
\prod_{-c \le j \le c, j \ne 0} {\frac{\exp\left( {e^{'}_{w_t}}^\top \cdot e_{w_{t+j}} \right)}{\sum_w \exp\left( {e^{'}_{w}}^\top \cdot e_{w_{t+j}} \right)} },
\label{eq:skip-gram}
\end{equation}
\fi

\subsection{Relation Constrained Model}
\label{ssec:train_rcm}
%We now present an objective that relies solely on task specific resources for training word embeddings.
Suppose we have a resource that indicates relations between words.
%To learn
%syntactic embeddings, we could have access to a dictionary of words and their associated part of speech tags:
%two words are similar when they can take the same part of speech.
In the case of semantics, we could have a resource that encodes semantic similarity between words.
Based on this resource, we learn embeddings that predict one word from another related word.
We define $\mathbf{R}$ as a set of relations between 
two words $w$ and $w'$. $\mathbf{R}$ can contain typed relations (e.g., $w$ is related to $w'$
through a specific type of semantic relation), and relations can have associated scores indicating
their strength. We assume a single relation type of uniform strength,
though it is straightforward to include additional characteristics into the objective.

Define $\mathbf{R}_w$ to be the subset of relations in $\mathbf{R}$ which involve word $w$. Our objective 
maximizes the (log) probability of all relations by summing over all words $N$ in the vocabulary:
\vspace{-.1cm}
\begin{equation}
\vspace{-.1cm}
\frac{1}{N} \sum_{i=1}^{N} \sum_{w \in \mathbf{R}_{w_i} } \log p\left( w | w_i \right),
\label{eq:pmm}
\end{equation}
%By Mo
$p(w|w_i) =  {\exp\left( {e'_{w}}^T e_{w_i} \right)}/ { \sum_{\bar{w}} \exp\left( {e'_{\bar{w}}}^T e_{w_i} \right)}$ takes a form similar to Eq. \eqref{eq:cbow} but without the context: 
%\vspace{-.1cm}
%\begin{equation}
%\vspace{-.31cm}
%\small
%p(w|w_i) = \frac{\exp\left( {e'_{w}}^\top e_{w_i} \right)}{\sum_{\bar{w}} \exp\left( {e'_{\bar{w}}}^\top e_{w_i} \right)},
%p(w|w_i) = \exp\left( {e'_{w}}^\top e_{w_i} \right) / \sum_{\bar{w}} \exp\left( {e'_{\bar{w}}}^\top e_{w_i} \right).\nonumber
%\vspace{-.1cm} %By Mo
%\end{equation}
$e$ and $e'$ are again the input and output embeddings. For our semantic relations
$e'_w$ and $e_w$ are symmetrical, so we use a single embedding.
Embeddings are learned such that they are predictive of related words in the resource.
We call this the Relation Constrained Model (RCM).

\subsection{Joint Model}
\label{ssec:train_joint}
The cbow and RCM objectives use separate data %By Mo sources 
for learning. While RCM learns
embeddings suited to specific tasks based on knowledge resources, cbow learns embeddings for words
not included in the resource but appear in a corpus. We form a joint model through a linear combination of the two (weighted
by $C$):% $\frac{1}{T} \sum_{t=1}^{T} \log p\left( w_t | w_{t-c~:~t+c} \right) 
% + C  \frac{1}{N} \sum_{i=1}^{N} \sum_{w \in \mathbf{R}_{w_i} } \log p\left( w | w_i \right)$.
\vspace{-.2cm}
% Eq.\eqref{eq:word2vec} and Eq.\eqref{eq:pmm}:
%\begin{small} %By Mo
\begin{equation}
\small
% \frac{1}{T} \sum_{t=1}^{T} \log p\left( w_t | w_{t-c~:~t+c} \right) 
 \frac{1}{T} \sum_{t=1}^{T} \log p\left( w_t | w_{t-c}^{t+c} \right) 
 + \frac{C}{N} \sum_{i=1}^{N} \sum_{w \in \mathbf{R}_{w_i} } \log p\left( w | w_i \right) \nonumber
% \vspace{-.2cm}
\end{equation}
 %\end{small}
Based on our initial experiments, RCM uses the output embeddings of cbow.

%By Mo:
We learn embeddings using stochastic gradient ascent. Updates for the first term for $e'$
and $e$ are:
%$e'_{w} - \alpha_{\textrm{cbow}} \left( \sigma(f(w)) - I_{[w=w_t]} \right)\cdot \sum_{j=t-c}^{t+c} e_{w_j} $
%and
%$e_{w_j} - \alpha_{\textrm{cbow}} \sum_{w}  \left( \sigma(f(w)) - I_{[w=w_t]} \right)\cdot e'_{w}$.
\vspace{-.3cm}
\begin{equation}
\small
e'_{w} - \alpha_{\textrm{cbow}} \left( \sigma(f(w)) - I_{[w=w_t]} \right)\cdot \sum_{j=t-c}^{t+c} e_{w_j} \nonumber
\end{equation}
\vspace{-.4cm}
\begin{equation}
\small
e_{w_j} - \alpha_{\textrm{cbow}} \sum_{w}  \left( \sigma(f(w)) - I_{[w=w_t]} \right)\cdot e'_{w}, \nonumber
\end{equation}
%\vspace{-.3cm}
%\begin{equation}
%\small
%e'_{w} - \alpha_{\textrm{cbow}} \left( \frac{\exp\{f(w)\}}{1+\exp\{f(w)\}} - I_{[w=w_t]} \right)\cdot \sum_{j=t-c}^{t+c} e_{w_j} \nonumber
%\end{equation}
%\begin{equation}
%\small
%e_{w_j} - \alpha_{\textrm{cbow}} \sum_{w}  \left( \frac{\exp\{f(w)\}}{1+\exp\{f(w)\}} - I_{[w=w_t]} \right)\cdot e'_{w} \nonumber
%\end{equation}
where $\sigma(x) = {\exp\{x\}}/{\left(1+\exp\{x\}\right)}$,
$I_{[x]}$ is 1 when $x$ is true, $f(w)={e'_w}^{\top} \sum_{j=t-c}^{t+c} e_{w_j}$. 
Second term updates are:
\vspace{-.2cm}
\begin{equation}
\small
e'_{w} - \alpha_{\textrm{RCM}} \left( \sigma(f'(w)) - I_{[w \in R_{w_i}]} \right)\cdot e'_{w_i} \nonumber
\end{equation}
\vspace{-.4cm}
\begin{equation}
\small
\vspace{-.1cm}
e'_{w_i} - \alpha_{\textrm{RCM}} \sum_{w}  \left( \sigma(f'(w)) - I_{[w \in R_{w_i}]} \right)\cdot e'_{w}, \nonumber
\end{equation}
where  $f'(w)={e'_w}^{\top}  e'_{w_i}$. We use two learning rates: $\alpha_{\textrm{cbow}}$ and $\alpha_{\textrm{RCM}}$.

\subsection{Parameter Estimation}
All three models (cbow, RCM and joint) use the same training scheme based on \newcite{mikolov2013distributed}.
There are several choices to make in parameter estimation; we present the best performing choices used in our results.

%DONE: How many negative examples?
%DONE: Are we using NCE or NEG? Unclear from the text.
We use noise contrastive estimation (NCE) \cite{mnih2012fast}, which approximately maximizes the log probability of the softmax objective
(Eq. \ref{eq:cbow}).
%By Mo
For each objective (cbow or RCM), we sample 15 words as negative samples for each training instance according
to their frequencies in raw texts (i.e. training data of cbow).
Suppose $w$ has frequency $u(w)$, then the probability of sampling $w$ is $p(w) \propto u(w)^{3/4}$.%/Z$, where $Z$ is the normalizer.
%DONE: Say more about training distribution since it matters a lot. How this distribution is used in both objectives. BY_MO: Do I need to add the last sentence? It is described in the reference \cite{mikolov2013distributed}

%DONE: Explain more about what this means. Provide details about stopping behavior and how we balance the objectives using multiple threads.
We use distributed training, where shared embeddings are updated by each thread based on training data within
the thread, i.e., asynchronous stochastic gradient ascent. For the joint model, 
we assign threads to the cbow or RCM objective with a balance
of 12:1(i.e. $C$ is approximately $\frac{1}{12}$). %DONE: Say how many threads each uses
%Since the training corpus for word2vec is much larger than the relations, we assign it more threads.
%Additionally, 
We allow the cbow threads to control convergence; training stops when these threads finish processing the data.
We found this an effective method for balancing the two objectives.
We trained each cbow objective using a single pass over the data set (except for those in \secref{ssec:train_lm}), which we 
empirically verified was sufficient to ensure stable performances on semantic tasks.

%TODO: Convergence and iterations. Do the cbow threads make a single pass of the data?

Model pre-training is critical in deep learning \cite{bengio2007greedy,erhan2010does}. We evaluate two
strategies: random initialization, and pre-training the embeddings. For pre-training, we first learn using cbow
with a random initialization. The resulting trained model is then used to initialize the RCM model. This enables
the RCM model to benefit from the unlabeled data, but refine the embeddings constrained by the given relations.
%We compare these strategies in our results.
%DONE: This section seems light on details. Please go through the word2vec paper and make sure we include any details
%for training that they include.

%\subsection{Initialize RCM with joint-learned embeddings}
Finally, we consider a final model for training embeddings that uses a specific training regime.
While the joint model balances between fitting the text and learning relations, modeling 
the text at the expense of the relations may negatively impact the final embeddings for tasks that use
the embeddings outside of the context of word2vec.
Therefore, we use the embeddings from a trained joint model to pre-train an RCM model.
We call this setting Joint$\rightarrow$RCM.

\section{Evaluation}
%By Mo
For training cbow we use the New York Times (NYT) 1994-97 subset from Gigaword v5.0 \cite{Parker:2011lr}.
% Gigaword v1.0 \cite{Graff:2003lr}.
We select 1,000 paragraphs each for dev and test data from 
the December 2010 portion of the NYT.
Sentences are tokenized using OpenNLP\footnote{\url{https://opennlp.apache.org/}}, yielding 
518,103,942 tokens for training, 42,953 tokens for dev and 41,344 for test.
%TODO: How do we filter out infrequent words? We only the top X words?

We consider two resources for training the RCM term:
the Paraphrase Database (PPDB) \cite{ganitkevitch2013ppdb} and
WordNet \cite{fellbaum1999wordnet}. For each semantic pair extracted from these
resources, we add a relation to the RCM objective. Since we use both resources 
for evaluation, we divide each into train, dev and test.

PPDB is an automatically extracted dataset containing tens of millions of paraphrase pairs, including words and phrases.
We used the ``lexical'' version of PPDB (no phrases) and filtered to include pairs that 
contained words found in the 200,000 most frequent
words in the NYT corpus, which ensures each word in the relations had support in the text corpus.
Next, we removed duplicate pairs: if $<$A,B$>$ occurred in PPDB, we removed relations of $<$B,A$>$.
PPDB is organized into 6 parts, ranging from S (small) to XXXL. Division into these sets is based on an automatically
derived accuracy metric. Since S contains the most accurate paraphrases, we used these for evaluation.
We divided S into a dev set (1582 pairs) and test set (1583 pairs). Training was based on one of the other sets minus relations
from S.

We created similar splits using WordNet, extracting synonyms using the 100,000 most frequent NYT words.
We divide the vocabulary into three sets: the most frequent 10,000 words, words with ranks between 10,001-30,000 and 30,001-100,000.
We sample 500 words from each set to construct a dev and test set. For each word we sample one synonym 
to form a pair. The remaining words and their synonyms are used for training. 
%By Mo
However we did not use the training data because it is too small to affect the results.
Table \ref{tab:data_stats} summarizes the datasets.

\begin{table}%[!h]
%\vspace*{-5pt}
%\setlength{\abovecaptionskip}{5pt}
%\setlength{\belowcaptionskip}{-15pt}

\small
\centering
	\begin{tabular}{|cc|c|c|c|}
	\hline
	 \multicolumn{2}{|c|}{\bf PPDB}   & \bf Relations & {\bf WordNet} & {\bf Relations} \\
	\hline
	Train & XL  & 115,041 & Train & 68,372\\
	& XXL & 587,439 & (not used in & \\ %By MO
	& XXXL & 2,647,105 & this work) & \\
	\hline
	Dev &  & 1,582 & Dev & 1,500\\
	Test & & 1,583 & Test & 1,500 \\
	\hline
	\end{tabular}
\caption{Sizes of semantic resources datasets.}
\label{tab:data_stats}
%\vspace{-.5cm} %By Mo
\end{table}


%
%
%\begin{table}%[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%
%\centering
%	\begin{tabular}{|c|c|}
%	\hline
%	\bf Dataset & \bf \#pairs \\
%	\hline
%	Dev & 1582\\
%	Test & 1583 \\
%	XL & 115041\\
%	XXL & 587439 \\
%	XXXL & 2647105 \\
%	\hline
%	\end{tabular}
%\caption{Statistics of PPDB datasets.}
%\label{tab:data_ppdb}
%\end{table}
%
%
%\begin{table}%[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%
%\centering
%	\begin{tabular}{|c|c|}
%	\hline
%	\bf Dataset & \bf \#pairs \\
%	\hline
%	Train & 68372 \\
%	Dev & 1500\\
%	Test & 1500 \\
%	\hline
%	\end{tabular}
%\caption{Statistics of WordNet synonym datasets.}
%\label{tab:data_wordnet}
%\end{table}


%DONE: What do we do when a word isn't in the top K of the NYT data? (What is K)? Do we shrink the context of surrounding words,
%or just delete the infrequent words and use the new context? BY_MO: we delete the infrequent words and use the remaining words in the window as context

\section{Experiments}
The goal of our experiments is to demonstrate the value of learning semantic embeddings with information from 
semantic resources. In each setting, we will compare the word2vec baseline
embedding trained with cbow against RCM alone, the joint model and Joint$\rightarrow$RCM.
We consider three evaluation tasks:
language modeling, measuring semantic similarity, and predicting human judgements on semantic relatedness.
In all of our experiments, we conducted model development and tuned model parameters ($C$, $\alpha_{\textrm{cbow}}$, 
$\alpha_{\textrm{RCM}}$, PPDB dataset, etc.)
on development data, and evaluate the best performing model on test data.
The models are notated as follows: word2vec for the baseline objective (cbow or skip-gram), RCM-r/p and Joint-r/p for random and pre-trained
initializations of the RCM and Joint objectives, and Joint$\rightarrow$RCM for pre-training RCM with Joint embeddings.
Unless otherwise notes, we train using PPDB XXL.
We initially created WordNet training data, but found it too small to affect results.
Therefore, we include only RCM results {\em trained} on PPDB, but show evaluations on both PPDB and WordNet.
We trained 200-dimensional embeddings and used output embeddings for measuring similarity.
During the training of cbow objectives we remove all words with frequencies less than 5, which is the default setting of word2vec.

\subsection{Language Modeling}
\label{ssec:train_lm}
%DONE: Question for the Joint model section in section 2. When we train jointly, which embeddings are shared between
%word2vec and RCM. The input embeddings? BY_MO: see the last sentence in Section 2.3
Word2vec is fundamentally a language model, which allows us to compute standard
evaluation metrics on a held out dataset. After obtaining trained embeddings from any of our objectives,
we use the embeddings in the word2vec model to measure perplexity of the test set.
Measuring perplexity means computing the exact probability of each word, which requires summation over
all words in the vocabulary in the denominator of the softmax. 
%By Mo
Therefore, we also trained the language models with hierarchical classification \cite{mikolov2013distributed} strategy (HS).
%Therefore, we also include the much faster to compute
%NCE loss \cite{mnih2012fast}, which approximates the likelihood through sampling (the same 15 negative word samples for each 
%model.)
%Results are reported on the NYT test set. 
%In order to efficiently compute the probability of each word, we used the hierarchical classification \cite{mikolov2013distributed} strategy.
The averaged perplexities are reported on the NYT test set.
 
%By Mo
While word2vec and joint are trained as language models, RCM is not. In fact, RCM does not even observe all the words that appear
in the training set, so it makes little sense to use the RCM embeddings directly for language modeling.
Therefore, in order to make fair comparison, for every set of trained embeddings, we fix them as input embedding for word2vec, then
%Instead, we take the trained embeddings that appear in RCM and fix them as input embeddings for word2vec, then 
learn the remaining input embeddings (words not in the relations) and all the output embeddings using cbow.
%In order to make fair comparisons, the same method is used when we use other sets of embedding to train language models with the same method.
Since this involves running cbow on NYT data for 2 iterations (one iteration for word2vec-training/pre-training/joint-modeling and the other for tuning the language 
model), 
%we also run the baseline cbow model for 2 iterations and 
we use Joint-r (random initialization)
for a fair comparison.
%DONE: Is this correct? 2 iterations? BY_MO: I made a mistake it should be joint-r in the table
%DONE: Mo wrote: "Table 9 is for first training a model and then tuning to be a LM. Therefore each model in Table 9 pass the NYT data twice and the results are different."
% I am only including table 9, so make sure this paragraph is accurate.
%The resulting embeddings can then be used as a language model.

%DONE: This table has lambda listed for the Joint model, but I thought it was a parameter of RCM? Why isn't it listed for RCM.
%DONE: Bold this table, explain the results.

\iffalse
\begin{table}[t]
\centering
\small
	\begin{tabular}{|l|c|c|}
	\hline
	\bf Model &  \bf NCE & \bf Perplexity\\
	\hline
	word2vec (cbow) & 3.504 & 8.75 \\
	\hline
	RCM-p & 3.557 & 8.55 \\ 
	Joint-r ($\alpha_{\textrm{RCM}}=1\times10^{-2}$) & 3.382  &  8.33 \\
	Joint-r ($\alpha_{\textrm{RCM}}=1\times10^{-3}$) & \bf 3.240  & \bf  8.20 \\
	Joint$\rightarrow$RCM & 3.451  &  8.40 \\
	\hline
	\end{tabular}
\caption{LM evaluation on held out NYT data.}
\label{tab:lm_results}
\end{table}
\fi

\begin{table}[t]
\centering
\small
	\begin{tabular}{|l|c|c|}
	\hline
	\bf Model & \bf NCE  & \bf HS\\
	\hline
	word2vec (cbow) & 8.75 & 6.90\\
	\hline
	RCM-p & 8.55 & 7.07 \\ 
	Joint-r ($\alpha_{\textrm{RCM}}=1\times10^{-2}$) & 8.33 & 6.87\\
	Joint-r ($\alpha_{\textrm{RCM}}=1\times10^{-3}$) & \bf  8.20 & \bf 6.75\\
	Joint$\rightarrow$RCM & 8.40 & 6.92\\
	\hline
	\end{tabular}
\caption{LM evaluation on held out NYT data.}
\label{tab:lm_results}
\end{table}

%By Mo
Table \ref{tab:lm_results} shows the results for language modeling on test data.  
All of our proposed models improve over the baseline in terms of perplexity when NCE is used for training LMs. 
When HS is used, the perplexities are greatly improved. However in this situation only the joint models improve the results; 
and Joint$\rightarrow$RCM performs similar to the baseline, although it is not designed for language modeling.
%leads to better perplexities except just RCM alone slightly hurts NCE.
We include the optimal $\alpha_{\textrm{RCM}}$ in the table; while set $\alpha_{\textrm{cbow}} = 0.025$ (the default setting of word2vec).
Even when our goal is to strictly model the raw text corpus, we obtain improvements
by injecting semantic information into the objective. RCM can effectively shift learning
to obtain more informative embeddings.


%\begin{table}[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%%\setcounter{table}{6}
%\centering
%	\begin{tabular}{|c|c|c|}
%	\hline
%	\bf System &  \bf NCE \\
%	\hline
%	word2vec cbow & 4.509 \\ %3.346
%	%nyt2004 3.214
%	%nyt2011 3.222
%	\hline
%	Joint-p (PPDB-xxl) ($\alpha_{\textrm{RCM}}$ = 1e-2) & 5.828   \\
%	Joint-p (PPDB-xxl) ($\alpha_{\textrm{RCM}}$ = 1e-3) & 3.763   \\
%	\hline
%	\end{tabular}
%\caption{Losses of LMs built on the embeddings}
%\label{tab:res_nce}
%\end{table}
%
%\begin{table}[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%%\setcounter{table}{6}
%\centering
%	\begin{tabular}{|c|c|c|}
%	\hline
%	\bf System &  \bf NCE & \bf PPL \\
%	%\hline
%	%word2vec cbow & 4.509  & 3.346 \\ %3.346
%	%nyt2004 3.214
%	%nyt2011 3.222
%	%\hline
%	%Joint-p (PPDB-xxl) ($\alpha_{\textrm{RCM}}$ = 1e-2) & 5.828  &  \\
%	%Joint-p (PPDB-xxl) ($\alpha_{\textrm{RCM}}$ = 1e-3) & 3.763  &  \\
%	\hline
%	word2vec & 3.504 & 8.75 \\
%	\hline
%	RCM-p (PPDB-xxl) & 3.557 & 8.55 \\ We expect it to do poorly.
%	Joint-p (PPDB-xxl) ($\alpha_{\textrm{RCM}}$ = 1e-2) & 3.382  & 8.33 \\
%	Joint-p (PPDB-xxl) ($\alpha_{\textrm{RCM}}$ = 1e-3) & 3.240 & 8.20   \\
%	\hline
%	\end{tabular}
%\caption{Losses of LMs built on the embeddings} %{Perplexities on NYT and MSR test data.}
%\label{tab:res_ppl}
%\end{table}
%
\begin{table*}[t]
%\vspace*{-5pt}
%\setlength{\abovecaptionskip}{5pt}
%\setlength{\belowcaptionskip}{-15pt}
%\setcounter{table}{3}
\centering
\small
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multirow{2}{*}{} &  \multicolumn{6}{|c|}{\bf PPDB} & \multicolumn{6}{|c|}{\bf WordNet}\\
	\multirow{2}{*}{\bf Model} &  \multicolumn{3}{|c|}{\bf Dev} & \multicolumn{3}{|c|}{\bf Test} &  \multicolumn{3}{|c|}{\bf Dev} & \multicolumn{3}{|c|}{\bf Test} \\
	\cline{2-13}
	& \bf 10k & \bf 30k & \bf 100k & \bf 10k & \bf 30k & \bf 100k & \bf 10k & \bf 30k & \bf 100k & \bf 10k & \bf 30k & \bf 100k \\
	\hline
	word2vec (cbow) & 49.68 & 39.26 & 29.15 & 49.31 & 42.53 & 30.28 & 10.24 & 8.64& 5.14& 10.04 & 7.90 & 4.97 \\
	word2vec (skip-gram) & 48.70 & 37.14 & 26.20 & - & - & - & 8.61 & 8.10 & 4.62 &- &- &- \\
	\hline
        RCM-r &55.03 & 42.52& 26.05 & - &- &- & 13.33 & 9.05 & 5.29 & - & - & - \\ 
	RCM-p  & 61.79 & 53.83 & 40.95  & 65.42 & 55.82& 41.20&15.25 &\bf 12.13 &7.46 & 14.13 & \bf 11.23 &7.39 \\
	Joint-r  & 59.91 & 50.87 & 36.81 & -& -& -&15.73 & 11.36 & 7.14 & 13.97 & 10.51 & 7.44\\ 
	Joint-p & 59.75 & 50.93 & 37.73 & 64.30& 53.27 & 38.97 & 15.61 & 11.20 & 6.96 & - & - & - \\
	Joint$\rightarrow$RCM & \bf 64.22 & \bf 54.99 & \bf 41.34 & \bf 68.20 & \bf 57.87 & \bf 42.64 & \bf 16.81 & 11.67 &\bf 7.55 & \bf 16.16 & 11.21 & \bf 7.56 \\ 
	%Joint$\rightarrow$RCM & 64.22 & 54.99 & 41.34 & & & \\
	\hline
	\end{tabular}
\caption{MRR for semantic similarity on PPDB and WordNet dev and test data. Higher is better. All RCM objectives are trained with PPDB XXL.
To preserve test data integrity, only the best performing setting of each model is evaluated on the test data.}
\label{tab:similarity}
\vspace{-.3cm}
\end{table*}
%DONE: Bold best entries in this table


%First we show the relation between performance of embeddings and the size of raw text for training. From \figref{fig:curve_mrr}, increasing the size of raw data can improve the performances of both word2vec and the RCM started with pre-trained word2vec embeddings. However the improvements on RCM is relatively smaller since the paraphrase data domained the optimization process. 
\subsection{Measuring Semantic Similarity}
Our next task is to find semantically related words using the embeddings, evaluating on relations from 
PPDB and WordNet. For each of the word pairs
in the evaluation set $<$A,B$>$, we use the cosine distance between the embeddings
to score $A$ with a candidate word $B'$.
We use a large sample of candidate words (10k, 30k or 100k)
and rank all candidate words for pairs where $B$ appears in the candidates.
We then measure the rank of the correct $B$
to compute mean reciprocal rank (MRR). Our goal is to use word $A$ to select word $B$
as the closest matching word from the large set of candidates.
Using this strategy, we evaluate the embeddings from all of our objectives
and measure which embedding most accurately selected the true correct word.

Table \ref{tab:similarity} shows MRR results for both PPDB and WordNet dev and test datasets
for all models. All of our methods improve over the baselines in nearly every test set result.
In nearly every case, Joint$\rightarrow$RCM obtained the largest improvements. Clearly,
our embeddings are much more effective at capturing semantic similarity.
%From the table, pre-training can greatly improve the results of RCMs trained on all of the PPDB training sets. The table also shows that the models trained on PPDB-XXL leads to best results. That is because PPDB is organized by confidences of paraphrases candidates. The larger the training set is, the wider coverage and the more noises it has. On our evaluation tasks, PPDB-XXL has the best balance of coverage and accuracy.


%Leave pre-training for later.
%Incorporate text below.




%
%We evaluate embeddings on the PPDB or WordNet evaluation sets as follows. Given a word $w$ with its embedding $e$ in the evaluation set, we rank all the other words in the vocabulary according to the cosine distances between their embeddings and $e$. Based on the rank list, we can use the MRR score of $w$'s paraphrases as a measure of quality of embeddings.
%
%In the third evalution task, we build features with the trained embeddings, and plug these features in a monolingual alignment model \cite{yao-EtAl:2013:Short}, in order to find how the embeddings will improve the baseline alignment results. The task of monolingual alignments requires features to indicate whether two words are representing same semantics thus can well serve as an evaluation task for semantic aspects of embeddings. In the experiments a new feature related to embeddings is added, which corresponds to the cosine distance between embeddings of a pair of words.
%
%Besides the semantic evaluation tasks, we also evaluate on the NYT test data the perplexities of language models trained by word2vec and the joint model in \secref{ssec:train_joint}. In this way we hope to verify whether the joint model can also lead to good language modeling results. For skip-gram models, the probabilities are computed as in \cite{mikolov2013efficient}.


%\tableref{tab:res_ppdb} shows the overall evaluation results on PPDB test data. Performances evaluated on different vocabularies (the most frequent 10000/30000/100000 words) are reported. It can be found the joint models can achieve similar results compared with those achieved by RCM-p; and the effects of pre-training on joint models are smaller. Moreover, since we believe the embeddings of Joint-p performs better than word2vec on this task, we add an experiment to train a RCM initialized with these embeddings. In this way we get the embeddings ($RCM_{joint}$), which leads to the best results on this task.
%
%Although RCMs get higher scores on PPDB test data, they can only captured semantic similarities of words and ignore all information from raw text. On the other hand, the joint model can benefit from multiple types of information. Therefore as will be shown in \secref{ssec:exp_lm}, the joint model can achieve both better semantic similarity and better language modeling compared to word2vec. 


\subsection{Human Judgements}
\label{ssec:exp_rank}
Our final evaluation is to predict human judgements of semantic relatedness.
We have pairs of words from PPDB scored by annotators
on a scale of 1 to 5 for quality of similarity. Our data are the judgements used by
\newcite{ganitkevitch2013ppdb}, which we filtered to include only those
pairs for which we learned embeddings, yielding 868 pairs.

We assign a score using the dot product between the output embeddings of each word in the pair,
then order all 868 pairs according to this score. Using the human judgements, we compute 
the swapped pairs rate:
the ratio between the number of swapped pairs and the number of all pairs.
For pair $p$ scored $y_p$ by the embeddings and judged $\hat{y}_p$ by an annotator, the swapped pair rate is:
\begin{equation}
\frac{\sum_{p_1,p_2 \in D} \textrm{I}[\left( y_{p_1} - y_{p_2}\right) \left( \hat{y}_{p_2} - \hat{y}_{p_1} \right) < 0] }{\sum_{p_1,p_2 \in D} \textrm{I}[y_{p_1} \ne y_{p_2}]}
\end{equation}
\noindent where $\textrm{I}[x]$ is 1 when $x$ is true.

\tableref{tab:res_rank} shows that all of our
models obtain reductions in error as compared to the baseline (cbow),
with Joint$\rightarrow$RCM obtaining the largest reduction.
This suggests that our embeddings are better suited for semantic tasks, in this case
judged by human annotations.

\begin{table}[!t]
\small
\centering
	\begin{tabular}{|l|c|}
	\hline
	\bf Model &  \bf Swapped Pairs Rate  \\
	\hline
	word2vec (cbow) & 17.81  \\
	\hline
	RCM-p & 16.66  \\
	Joint-r & 16.85   \\
	Joint-p & 16.96   \\
	Joint$\rightarrow$RCM & \bf 16.62 \\
	\hline
	\end{tabular}
\caption{Results for ranking the quality of PPDB pairs as compared to human judgements.}
\label{tab:res_rank}
\vspace{+.1cm}
\end{table}



\begin{table}[t]
%\vspace{-.3cm} %By Mo
%\vspace*{-5pt}
%\setlength{\abovecaptionskip}{5pt}
%\setlength{\belowcaptionskip}{-15pt}
%\setcounter{table}{2}
\small
\centering
	\begin{tabular}{|ll|c|c|c|}
	\hline
	 & &  \multicolumn{3}{|c|}{\bf PPDB Dev } \\
	\cline{3-5}
	{\bf Model} & {\bf Relations} & \bf 10k & \bf 30k & \bf 100k \\
	\hline
        RCM-r  &XL &24.02 & 15.26& 9.55  \\ 
	RCM-p &XL & 54.97 & 45.35 & 32.95  \\
        RCM-r  &XXL &55.03 & 42.52& 26.05  \\ 
	RCM-p &XXL & \bf 61.79 & \bf 53.83 & \bf 40.95  \\
        RCM-r  &XXXL &51.00 & 44.61& 28.42  \\ 
	RCM-p &XXXL & 53.01 & 46.35 & 34.19  \\
	\hline
	%Joint-r (XXL) &  &  &  \\
	%Joint-p (XXL) & &  &  \\
	%\hline
	\end{tabular}
\caption{MRR on PPDB dev data for training on an increasing number of relations.}
\label{tab:res_ppdb_size}
\vspace{-.1cm}
\end{table}


%%DONE: Maybe take out this figure since its based on gigaword 5
%\begin{figure}[!h]%[htbp] %DONE: figure in pdf or eps format
%\includegraphics[scale=0.36]{MRR.eps}
%\caption{Performances of learned embeddings on PPDB development data.}
%\label{fig:curve_mrr}
%\end{figure}

\iffalse
\begin{figure}[!h]%[htbp]
\includegraphics[scale=0.36]{MRR_wordnet.png}
\caption{Performances of learned embeddings on WordNet synonym test data}
\label{fig:curve_mrr_wordnet}
\end{figure}
\fi

\begin{table}[!h]
%\vspace*{-5pt}
%\setlength{\abovecaptionskip}{5pt}
%\setlength{\belowcaptionskip}{-15pt}
%\setcounter{table}{2}
\small
\centering
	\begin{tabular}{|l|l|c|c|c|}
	\hline
	 & &  \multicolumn{3}{|c|}{\bf PPDB Dev } \\
	\cline{3-5}
	{\bf Model} & $\alpha_{\textrm{RCM}}$ & \bf 10k & \bf 30k & \bf 100k \\
	\hline
         Joint-p & $1 \times 10^{-1}$ & 47.17 & 36.74  &  24.50  \\ 
	& $5 \times 10^{-2}$ & 54.31 & 44.52 & 33.07 \\
	& $1 \times 10^{-2}$ & \bf 59.75 & \bf 50.93 & \bf 37.73  \\
	& $1 \times 10^{-3}$ & 57.00 & 46.84 & 34.45  \\
	\hline
	\end{tabular}
\caption{Effect of learning rate $\alpha_{\textrm{RCM}}$ on MRR for the RCM objective in Joint models.}
\label{tab:res_ppdb_learningrate}
\end{table}

%\begin{table}[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%%\setcounter{table}{3}
%\centering
%	\begin{tabular}{|c|c|c|c|}
%	\hline
%	\multirow{2}{*}{\bf System} &  \multicolumn{3}{|c|}{\bf MRR } \\
%	\cline{2-4}
%	& \bf 10000 & \bf 30000 & \bf 100000 \\
%	\hline
%	word2vec cbow & 49.68 & 39.26 & 29.15\\
%	word2vec skip-gram & 48.70 & 37.14 & 26.20\\
%	\hline
%        RCM-r  (PPDB-xxl) &55.03 & 42.52& 26.05  \\ 
%	RCM-p  (PPDB-xxl) & 61.79 & 53.83 & 40.95  \\
%	Joint-r (PPDB-xxl) & 59.91 & 50.87 & 36.81 \\ 
%	Joint-p (PPDB-xxl) & 59.75 & 50.93 & 37.73 \\
%	$RCM_{Joint}$ & 64.21 & 54.60 & 40.50\\ 
%	%Joint$\rightarrow$RCM & 64.22 & 54.99 & 41.34\\
%	\hline
%	\end{tabular}
%\caption{Performances on PPDB development data.}
%\label{tab:res_ppdb}
%\end{table}
%
%\begin{table}[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%%\setcounter{table}{3}
%\centering
%	\begin{tabular}{|c|c|c|c|}
%	\hline
%	\multirow{2}{*}{\bf System} &  \multicolumn{3}{|c|}{\bf MRR } \\
%	\cline{2-4}
%	& \bf 10000 & \bf 30000 & \bf 100000 \\
%	\hline
%	word2vec cbow &  &  & \\
%	\hline
%	RCM-p  (PPDB-xxl) &  & &   \\
%	Joint-p (PPDB-xxl) &  &  &  \\
%	$RCM_{Joint}$ & &  & \\ 
%	\hline
%	\end{tabular}
%\caption{Performances on PPDB test data.}
%\label{tab:res_ppdb_test}
%\end{table}

\vspace{-0.1 in} 
\subsection{Analysis}
We conclude our experiments with an analysis of modeling choices. First, pre-training RCM models gives
significant improvements in both measuring semantic similarity and capturing human judgements (compare ``p'' vs. ``r'' results.)
Second, the number of relations used for RCM training is an important factor. Table \ref{tab:res_ppdb_size} shows the effect
on dev data of using various numbers of relations. While we see improvements from XL to XXL (5 times as many relations), we
get worse results on XXXL, likely because this set contains the lowest quality relations in PPDB.
Finally, Table \ref{tab:res_ppdb_learningrate} shows different learning rates $\alpha_{\textrm{RCM}}$
for the RCM objective.

The baseline word2vec and the joint model have nearly the same averaged running times (2,577s and 2,644s respectively), since they have same number of threads for the CBOW objective and the joint model uses additional threads for the RCM objective. The RCM models are trained with single thread for 100 epochs. When trained on the PPDB-XXL data, it spends 2,931s on average.


%\subsection{Performances on WordNet test data}

%\tableref{tab:res_wordnet} shows the evaluation results on WordNet test data. The results show similar regularity as that shown by results on PPDB data. We also trained embeddings with the help of WordNet training data for comparison. From the results, the models trained on WordNet training data achieved the best performance. However, the performances of embeddings trained on PPDB data are comparable with the best performance, showing that the semantic knowledge contained by PPDB can be well generalized to other knowledge base such as WordNet. 
%
%The embeddings trained on WordNet training data only (RCM-r) get poor results, which is mainly because the training data is too small (much smaller than PPDB-XL according to \tableref{tab:data_wordnet}). That indicate the WordNet data mainly works as a kind of regularization in the joint models, showing the advantage of joint models when the semantic knowledge base is small.

%\begin{table}[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%%\setcounter{table}{4}
%\centering
%	\begin{tabular}{|c|c|c|c|}
%	\hline
%	\multirow{2}{*}{\bf System} &  \multicolumn{3}{|c|}{\bf MRR } \\
%	\cline{2-4}
%	& \bf 10000 & \bf 30000 & \bf 100000 \\
%	\hline
%	word2vec cbow & 10.24 & 8.64 & 5.14\\
%	word2vec skip-gram & 8.61 & 8.10 & 4.62 \\
%	\hline
%        RCM-r (PPDB-xxl) &13.33 & 9.05 & 5.29  \\
%	RCM-p (PPDB-xxl) & 15.25 & 12.13 & 7.46  \\
%	Joint-r (PPDB-xxl) & 15.73 & 11.36 & 7.14 \\
%	Joint-p (PPDB-xxl) & 15.61 & 11.20 & 6.96  \\
%	$RCM_{Joint}$ & 16.81 & 11.67 & 7.55\\
%	\hline
%	RCM-r (WordNet) & 0.46 & 1.41 & 1.13 \\ 
%	RCM-p (WordNet) & 14.56 & 10.82 & 7.24  \\
%	Joint-r (WordNet) & 13.97 & 11.45 & 7.79 \\
%	Joint-p (WordNet) & 16.47 & 13.02 & 8.59 \\
%	\hline
%	\end{tabular}
%\caption{Performances on WordNet synonym data (development data).}
%\label{tab:res_wordnet}
%\end{table}

%\iffalse
%\subsection{Performances on the application of mono-lingual alignments}
%
%Table 3 shows the performances of different embeddings on the monolingual alignment task. \textcolor{red}{todo: Unfortunately, embedding-based features hurt the performances. We will carry out a further study on the usage of embeddings in monolingual alignment models}.
%
%\begin{table}[!h]
%%\vspace*{-5pt}
%%\setlength{\abovecaptionskip}{5pt}
%%\setlength{\belowcaptionskip}{-15pt}
%%\setcounter{table}{5}
%\centering
%	\begin{tabular}{|c|c|c|c|}
%	\hline
%	\multirow{2}{*}{\bf System} &  \multicolumn{3}{|c|}{\bf Performances } \\
%	\cline{2-4}
%	& \bf Prec & \bf Rec & \bf F1 \\
%	\hline
%	baseline & 91.0 & 81.3 & 85.9\\
%	\hline
%	word2vec &  &  & \\
%	\hline
%        RCM-r (PPDB-xxl) &  &  &    \\
%	RCM-p (PPDB-xxl) & 91.2 & 81.2 & 85.9 \\
%	Joint-r (PPDB-xxxl) & & & \\
%	Joint-p (PPDB-xxxl) & & & \\
%	\hline
%	full model \cite{yao-EtAl:2013:Short} & 91.1& 83.8 & 87.3 \\
%	\hline
%	\end{tabular}
%\caption{Performances on mono-lingual alignment.}
%\label{tab:res_mono}
%\end{table}
%\fi




\section{Conclusion}
We have presented a new learning objective for neural language models that incorporates
prior knowledge contained in resources to improve learned word embeddings.
We demonstrated that the Relation Constrained Model can lead to better semantic embeddings
by incorporating resources like PPDB, leading to better language modeling, semantic similarity metrics,
and predicting human semantic judgements. Our implementation is based on the word2vec package
and we made it available for general use
%By Mo
\footnote{https://github.com/Gorov/JointRCM}.

We believe that our techniques have implications beyond those considered in this work. We plan
to explore the embeddings suitability for other semantics tasks, including the use of resources
with both typed and scored relations. Additionally, we see opportunities for jointly learning embeddings across
many tasks with many resources, and plan to extend our model accordingly.
% by dividing the embedding $e_w$ for a word $w$ into three parts: $e_w=\left[e_{w}^0:e_{w}^1:e_{w}^2\right]$

\iffalse
\begin{align*}
L = & \sum_{t\in \{1,2\}} \alpha_t \cdot \frac{1}{N_t} \sum_{i=1}^{N_t} \sum_{w \in \Omega_t(w_i) } \log p_t \left( w | w_i \right),
\end{align*}
where $\alpha_t$ is the weight of task $t$. $\Omega_t$ is the set of words to predict in task $t$. The probability $p_t$ is defined as:
\[
p_t(w_O|w_I) = \frac{\exp\left( { [e^{'0}_{w_O}:e^{'t}_{w_O} ]}^\top [e_{w_I}^0:e_{w_I}^t] \right)}{\sum_w \exp\left( { [e^{'0}_{w}:[e^{'t}_{w}] }^\top [e_{w_I}^0:e_{w_I}^t] \right)}.
\]
In this way each task $t$ only updates the task-specific embeddings $e^t$ and the shared embeddings $e^0$.

The method in \secref{ssec:train_joint} is a special case of the proposed multitask learning algorithm, with $e_w = e_w^0$.
\fi

%By Mo
\paragraph{Acknowledgements}
Yu is supported by China Scholarship Council and by
NSFC 61173073.
%National Natural Science Foundation of China (61173073).

\bibliographystyle{acl2012}
% you bib file should really go here 
\bibliography{acl2014_short.bib}
%\nocite{*}

\end{document}
